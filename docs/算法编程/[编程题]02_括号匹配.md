---
title: '[编程题]02_括号匹配'
category: 编程题
tag: 编程题
date: 2018-03-20 00:01:00
---


# 题目

括号匹配，() , {} ,[] 为匹配

## Input

第一个参数 M 是测试用例的个数， 之后输入 M  行测试用例，输入只包含 `(){}[]`
```
3
{[](()}
[][]()
()(([]))
```

## Output


输出每行的匹配结果
```
false
true
true
```

# Coding

栈的使用



## 2018-04-04更新

今天脑子比较清醒，看了下以前的代码，简直不认直视。复杂度太高，占用内存太多。主要原因是 new 的实例太多，判断太多，于是重新考虑换个算法。
观察括号的 asc码之后发现了新大陆。


```
  ( = 40 ，  )=41
  [ = 91 ，  ]=93
  { = 123，  }=125

```
1. `匹配` 的括号之间的差满足：  `0 < 差  < 3 ` => `41-40=1  93-91=2  125-123=2`

那么再用栈不就是几行代码的事么

### Java代码


```
    public  boolean isValid(String s) {
        //奇数个字符，不匹配
        if (s.length() % 2 != 0) {
            return false;
        }
        
        // 栈不为空 && c 和 栈顶 匹配 ？弹栈  ： c 进栈
        Stack<Character> st = new Stack<>();
        for (char c : s.toCharArray()) {
            Character n = !st.isEmpty() && ((c - st.lastElement()) < 3) && ((c - st.lastElement()) > 0) ? st.pop() : st.push(c);
        }
        return st.isEmpty();
    }

```



## 2018-0302 更新
```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

public class KuoHaoPipei {

    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(System.in);

        //测试用例的个数
        int n = s.nextInt();

        //按行 读取测试用例
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        for (int i = 0; i < n; i++) {

            String s1 = bf.readLine();
            //将 字符串拆成 char数组
            char[] chars = s1.toCharArray();
            //将 char 数组元素进行匹配， 输出匹配的结果
            boolean re = pipei(chars);
            System.out.println(re);
        }


    }


    public static boolean pipei(char[] chars) {

        Stack<Character> stack = new Stack<>();

        //如果长度是 奇数， 不匹配
        if (chars.length % 2 != 0) {
            return false;
        }
        //放入元素 ， 与栈顶元素比较
        for (char aChar : chars) {
            //如果栈为空，添加一个元素，不做其他处理
            if (stack.empty()) {
                stack.push(aChar);
            } else {
                //栈不为空， 栈顶元素 与 栈顶第二个元素比较 ，（） [] 为匹配
                stack.push(aChar);
                if ((stack.get(stack.size() - 2).toString().equals("(")) && stack.get(stack.size() - 1).toString().equals(")")
                        || (stack.get(stack.size() - 2).toString().equals("[") && stack.get(stack.size() - 1).toString().equals("]"))
                        || (stack.get(stack.size() - 2).toString().equals("{") && stack.get(stack.size() - 1).toString().equals("}"))) {
                    //匹配，栈顶 两个元素 弹栈 ，栈空
                    stack.pop();
                    stack.pop();
                }
            }
        }

        return stack.empty();
    }
}

```
