(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{358:function(v,_,a){"use strict";a.r(_);var s=a(13),e=Object(s.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"类加载顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载顺序"}},[v._v("#")]),v._v(" 类加载顺序")]),v._v(" "),a("p",[a("img",{attrs:{src:"//willon.cn/images/classloader.png",alt:""}})]),v._v(" "),a("p",[v._v("大致过程")]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("加载  -> 验证  -> 准备  -> 解析 -> 初始化  ->  使用  -> 卸载\n")])])]),a("ol",[a("li",[a("p",[v._v("加载")]),v._v(" "),a("ul",[a("li",[v._v("通过类的全限定名，获取其定义的二进制字节流")]),v._v(" "),a("li",[v._v("将字节流代表的存储结构转化成方法区的运行时数据结构（还没有进入方法区）")]),v._v(" "),a("li",[v._v("在 堆中生成一个代表类的对象， 作为对方法区中这些数据 的访问入口")])])]),v._v(" "),a("li",[a("p",[v._v("验证"),a("br"),v._v("\n确保Class文件中的字节流信息符合当前虚拟机的要求，不会危害虚拟机的安全。大致验证： "),a("code",[v._v("文件格式的验证")]),v._v(" 、"),a("code",[v._v("元数据的验证")]),v._v(" 、"),a("code",[v._v("字节码验证")]),v._v(" 和 "),a("code",[v._v("符号引用验证")]),v._v(" 。")]),v._v(" "),a("ul",[a("li",[v._v("文件格式验证： 验证 "),a("code",[v._v("字节流")]),v._v(" 是否符合 "),a("code",[v._v("class")]),v._v(" 文件规范")]),v._v(" "),a("li",[v._v("元数据验证： 对数据进行 语法校验，保证其 符合 Java 语法规范")]),v._v(" "),a("li",[v._v("字节码验证： 数据流、控制流分析，确保方法运行不会危害到 JVM")]),v._v(" "),a("li",[v._v("符号引用验证： 对类之外的信息（常量池的各种符号引用） 进行匹配性的校验")])])]),v._v(" "),a("li",[a("p",[v._v("准备")]),v._v(" "),a("p",[v._v("正式为 "),a("code",[v._v("类变量 分配内存")]),v._v(" 并且设置 "),a("code",[v._v("类变量初始值")]),v._v(" 的阶段")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("仅仅包含 static 变量， 不包含实例变量， 实例变量 会在类初始化时进入 "),a("code",[v._v("堆")])])]),v._v(" "),a("li",[a("p",[v._v("通常默认值是 "),a("code",[v._v("0 ， 0L , null , false")]),v._v(" , "),a("strong",[v._v("不会")]),v._v(" 执行显示赋值,如下")]),v._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("static")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("int")]),v._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[v._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),a("p",[v._v("a=3 会在 "),a("code",[v._v("初始化阶段")]),v._v("  执行， 此 准备阶段 "),a("code",[v._v("a=0")])])])])]),v._v(" "),a("li",[a("p",[v._v("解析\n虚拟机将 "),a("code",[v._v("常量池")]),v._v("  中的 "),a("code",[v._v("符号引用")]),v._v("  转化为 "),a("code",[v._v("直接引用")])]),v._v(" "),a("ul",[a("li",[v._v("类和接口解析：  判断解析成直接引用还是数组类型")]),v._v(" "),a("li",[v._v("字段解析： 会一直向上层父类解析，直到找到 引用为止，比如 "),a("code",[v._v("name")]),v._v(" 属性， 如果子类没有， 会一直向上层父类查找")]),v._v(" "),a("li",[v._v("方法解析： 判断该方法处于类还是接口，并且进行对应的解析")])])]),v._v(" "),a("li",[a("p",[v._v("初始化\n类加载的最后一步，真正开始执行 Java类中的各个实例的赋值，一个各种变量初始化")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);