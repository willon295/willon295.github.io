(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{394:function(n,t,e){"use strict";e.r(t);var s=e(13),r=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"题目"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[n._v("#")]),n._v(" 题目")]),n._v(" "),e("p",[n._v("给定两个整数M，N，生成一个M*N的矩阵，矩阵中元素取值为A至Z的26个字母中的一个，A在左上角，其余各数按顺时针方向旋转前进，依次递增放置，当超过26时又从A开始填充。例如，当M=5，N=8时，矩阵中的内容如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("   A   B   C   D   E   F   G   H\n\n   V   W   X   Y   Z   A   B   I\n\n   U   J   K   L   M   N   C   J\n\n   T   I   H   G   F   E   D   K\n\n   S   R   Q   P   O   N   M   L\n")])])]),e("h2",{attrs:{id:"input"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#input"}},[n._v("#")]),n._v(" Input")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("4 9\n")])])]),e("h2",{attrs:{id:"output"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#output"}},[n._v("#")]),n._v(" Output")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("   A   B   C   D   E   F   G   H   I\n   V   W   X   Y   Z   A   B   C   J\n   U   J   I   H   G   F   E   D   K\n   T   S   R   Q   P   O   N   M   L\n")])])]),e("h1",{attrs:{id:"coding"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#coding"}},[n._v("#")]),n._v(" Coding")]),n._v(" "),e("p",[n._v("用面向对象的思想思考这道题就很费劲了，想是一回事，实现又是另一回事了，逻辑要十分严密，复杂度不可过高，可以使用递归")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('import java.util.*;\n\npublic class XuanZhuanZiMu2 {\n\n\n    /*1. 输入  R * C 的矩阵\n      2. A 在 左上角 ，起点， 其他字母按  顺时针 顺序排列\n      3. 当字母到达 Z 之后， 从 A 重新开始\n      */\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int R = s.nextInt();\n        int C = s.nextInt();\n        go(R, C);\n    }\n\n\n    //方法重载，简化输入\n    public static void go(int R, int C) {\n        String[][] ele = new String[R][C];\n        ele[0][0] ="A";\n        go(0, 1, R, C, 0, ele, 1);\n        \n        //输出矩阵内的元素\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n\n                System.out.print(ele[i][j]);\n            }\n            System.out.println();\n        }\n    }\n\n    /**\n     * 递归遍历每个元素， 第 n 次 循环结束， 起始点边界 +n ，结束点边界 -n。 当不满足任意方向时，代表下一轮循环开始，round++\n     *\n     * @param i        当前行 索引\n     * @param j        当前列索引\n     * @param R        矩阵行数\n     * @param C        矩阵列数\n     * @param round    第几轮循环\n     * @param elements 矩阵\n     * @param step     一共走的步数\n     */\n    public static void go(int i, int j, int R, int C, int round, String[][] elements, int step) {\n        //定义数据字典\n        String[] sa = {\n                "A", "B", "C", "D",\n                "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",\n                "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X",\n                "Y", "Z"};\n        List<String> l = new ArrayList<>(Arrays.asList(sa));\n        //排序\n        Collections.sort(l);\n        if (i == round && j < C - (round + 1)) {\n            //在 i==round 说明在空闲区 起始位置 ，向右移动，可移动到列 C -(round+1) 位置\n            //System.out.println("当前位置：" + i + "--" + j + "\\t: 向右走");\n            elements[i][j] = l.get(step % 26);\n            j++;\n            step++;\n            if (step >= R * C) {\n                return;\n            }\n            elements[i][j] = l.get(step % 26);\n            go(i, j, R, C, round, elements, step);\n        } else if (i == R - (round + 1) && j > round) {\n\n            //在 i = R-(round+1) 时 ，说明在 空闲区 最后一行 最后一列 ，可 向左  移动 round 列\n            elements[i][j] = l.get(step % 26);\n            j--;\n            step++;\n            if (step >= R * C) {\n                return;\n            }\n            elements[i][j] = l.get(step % 26);\n            go(i, j, R, C, round, elements, step);\n        } else if (i < R - (round + 1) && j == C - (round + 1)) {\n\n            //在  j == C - (round + 1) 时，说明在空闲区 第一行 最后 一列，可  向下   移动至  R - (round + 1) 行\n            //System.out.println("当前位置：" + i + "--" + j + "\\t: 向下走");\n            elements[i][j] = l.get(step % 26);\n            i++;\n            step++;\n            if (step >= R * C) {\n                return;\n            }\n            elements[i][j] = l.get(step % 26);\n            go(i, j, R, C, round, elements, step);\n        } else if (i > round + 1 && j == round) {\n\n            //当前处于空闲区第一列，最后一行，可以  向上  移动 至 round + 1 行\n            //System.out.println("当前位置：" + i + "--" + j + "\\t: 向上走");\n            elements[i][j] = l.get(step % 26);\n            i--;\n            step++;\n            if (step >= R * C) {\n                return;\n            }\n            elements[i][j] = l.get(step % 26);\n            go(i, j, R, C, round, elements, step);\n        } else {\n\n            //不满足任何方向移动，说明下一轮循环开始 ， round++, 再递归\n            round++;\n            if (step >= R * C - 1) {\n                return;\n            }\n            go(i, j, R, C, round, elements, step);\n        }\n\n    }\n\n}\n\n\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);