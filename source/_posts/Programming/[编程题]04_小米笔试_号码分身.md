---
title: '[编程题]04_小米笔试_号码分身'
category: 编程题
tag: 编程题
date: 2018-03-20 00:04:00
---

# 题目

继MIUI8推出手机分身功能之后，MIUI9计划推出一个电话号码分身的功能： 
1. 首先将电话号码中 每个数字 加上 8   , 取个位
2. 使用对应的大写字母代替 （"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT","NINE"
3.  然后随机打乱这些字母，所生成的字符串即为电话号码对应的分身

## 题目解释

难点在于如何将随机的字符串转化成有意义的单词，仔细观察 9 个单词，找出规律：
如 `ZERO` 独有的 `Z`, `EIGHT` 独有的 `G`, `TWO` 独有的 `W`, `SIX` 独有的 `X` 

## Input

第一行是一个整数T（1 ≤ T ≤ 100)表示测试样例数；接下来T行，每行给定一个分身后的电话号码的分身（长度在3到10000之间）。
```
4
EIGHT
ZEROTWOONE
OHWETENRTEO
OHEWTIEGTHENRTEO
```

## Output

输出T行，分别对应输入中每行字符串对应的分身前的最小电话号码（允许前导0）

```
0
234
345
0345
```

# Coding



```
// 1. 将输入的   随机字母   组合成  一串有意义 的 英文
// 2. 将对应的  英文 转化成  数字
// 3. 所有  数字 减8   => 得到多个  新的数字　　　　
// 4. 新的数字串  排列成 最小的数字串  可以 0 开头　
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String sar[] = new String[n];
        for (int i = 0; i < n; i++) {
            sar[i] = sc.next();
        }
        for (String s : sar) {
            resolve(s);
            System.out.println();
        }
    }
    public static void resolve(String s) {

        // `-8 取个位 ` (即 （i+2） % 10) 之后的索引，表示  `转换之后` 的 数字
        // 出现一次 arr[i]++ ，最后 arr[i] 表示出现的次数
        // 可以巧妙的省去 重新排列的问题
        int arr[] = new int[10];
        StringBuilder sb = new StringBuilder(s);
        while (sb.toString().contains("Z")) { //0  独有Z, 删除 Z E R O  剩下 4 , 3 有 R
            arr[2]++;
            sb.deleteCharAt(sb.toString().indexOf("Z"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("R"));
            sb.deleteCharAt(sb.toString().indexOf("O"));
        }
        while (sb.toString().contains("W")) { //2  独有的 W ，删除 T W O
            arr[4]++;
            sb.deleteCharAt(sb.toString().indexOf("T"));
            sb.deleteCharAt(sb.toString().indexOf("W"));
            sb.deleteCharAt(sb.toString().indexOf("O"));
        }
        while (sb.toString().contains("X")) { //6 ，独有的X ，删除 SIX ，剩下 7 有 S
            arr[8]++;
            sb.deleteCharAt(sb.toString().indexOf("S"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("X"));
        }
        while (sb.toString().contains("S")) { // 7 , 删除 SEVEN
            arr[9]++;
            sb.deleteCharAt(sb.toString().indexOf("S"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("V"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("N"));
        }

        while (sb.toString().contains("U")) { //4   独有的 U ， 删除 FOUR， 剩下 5 有 F, 3 有 R
            arr[6]++;
            sb.deleteCharAt(sb.toString().indexOf("F"));
            sb.deleteCharAt(sb.toString().indexOf("O"));
            sb.deleteCharAt(sb.toString().indexOf("U"));
            sb.deleteCharAt(sb.toString().indexOf("R"));
        }
        while (sb.toString().contains("F")) {//5  在 4 之后，只有 5 有 F
            arr[7]++;
            sb.deleteCharAt(sb.toString().indexOf("F"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("V"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
        }

        while (sb.toString().contains("G")) { //8， 独有的 G, 
            arr[0]++;
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("G"));
            sb.deleteCharAt(sb.toString().indexOf("H"));
            sb.deleteCharAt(sb.toString().indexOf("T"));
        }

        //剩下 1 9  ONE NINE
        while (sb.toString().contains("O")) { //1 
            arr[3]++;
            sb.deleteCharAt(sb.toString().indexOf("O"));
            sb.deleteCharAt(sb.toString().indexOf("N"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
        }
        while (sb.toString().contains("I")) { //9
            arr[1]++;
            sb.deleteCharAt(sb.toString().indexOf("N"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("N"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
        }

        // 索引 i 的值  arr[i] 不为0, 输出 i，输出次数为 arr[i]
        for (int i = 0; i < arr.length; i++) {
            // arr[i] >= 1 时，循环输出
            if (arr[i]!=0){
                for (int j = 0; j <arr[i] ; j++) {
                    System.out.print(i);
                }
            }

        }

    }
}




```
