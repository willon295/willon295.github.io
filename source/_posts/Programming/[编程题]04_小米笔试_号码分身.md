---
title: '[编程题]04_小米笔试_号码分身_数字单词还原'
category: 编程题
tag: 编程题
date: 2018-03-20 00:04:00
---

# 题目

继MIUI8推出手机分身功能之后，MIUI9计划推出一个电话号码分身的功能： 
1. 首先将电话号码中 每个数字 加上 8   , 取个位
2. 使用对应的大写字母代替 （"ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT","NINE"
3.  然后随机打乱这些字母，所生成的字符串即为电话号码对应的分身

## 题目解释

难点在于如何将随机的字符串转化成有意义的单词，仔细观察 9 个单词，找出规律：
如 `ZERO` 独有的 `Z`, `EIGHT` 独有的 `G`, `TWO` 独有的 `W`, `SIX` 独有的 `X` 

## Input

第一行是一个整数T（1 ≤ T ≤ 100)表示测试样例数；接下来T行，每行给定一个分身后的电话号码的分身（长度在3到10000之间）。
```
4
EIGHT
ZEROTWOONE
OHWETENRTEO
OHEWTIEGTHENRTEO
```

## Output

输出T行，分别对应输入中每行字符串对应的分身前的最小电话号码（允许前导0）

```
0
234
345
0345
```

# Coding



```
// 1. 将输入的   随机字母   组合成  一串有意义 的 英文
// 2. 将对应的  英文 转化成  数字
// 3. 所有  数字 减8   => 得到多个  新的数字　　　　
// 4. 新的数字串  排列成 最小的数字串  可以 0 开头　
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String sar[] = new String[n];
        for (int i = 0; i < n; i++) {
            sar[i] = sc.next();
        }
        for (String s : sar) {
            resolve(s);
            System.out.println();
        }
    }
    public static void resolve(String s) {

        // `-8 取个位 ` (即 （i+2） % 10) 之后的索引，表示  `转换之后` 的 数字
        // 出现一次 arr[i]++ ，最后 arr[i] 表示出现的次数
        // 可以巧妙的省去 重新排列的问题
        int arr[] = new int[10];
        StringBuilder sb = new StringBuilder(s);
        while (sb.toString().contains("Z")) { //0  独有Z, 删除 Z E R O  剩下 4 , 3 有 R
            arr[2]++;
            sb.deleteCharAt(sb.toString().indexOf("Z"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("R"));
            sb.deleteCharAt(sb.toString().indexOf("O"));
        }
        while (sb.toString().contains("W")) { //2  独有的 W ，删除 T W O
            arr[4]++;
            sb.deleteCharAt(sb.toString().indexOf("T"));
            sb.deleteCharAt(sb.toString().indexOf("W"));
            sb.deleteCharAt(sb.toString().indexOf("O"));
        }
        while (sb.toString().contains("X")) { //6 ，独有的X ，删除 SIX ，剩下 7 有 S
            arr[8]++;
            sb.deleteCharAt(sb.toString().indexOf("S"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("X"));
        }
        while (sb.toString().contains("S")) { // 7 , 删除 SEVEN
            arr[9]++;
            sb.deleteCharAt(sb.toString().indexOf("S"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("V"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("N"));
        }

        while (sb.toString().contains("U")) { //4   独有的 U ， 删除 FOUR， 剩下 5 有 F, 3 有 R
            arr[6]++;
            sb.deleteCharAt(sb.toString().indexOf("F"));
            sb.deleteCharAt(sb.toString().indexOf("O"));
            sb.deleteCharAt(sb.toString().indexOf("U"));
            sb.deleteCharAt(sb.toString().indexOf("R"));
        }
        while (sb.toString().contains("F")) {//5  在 4 之后，只有 5 有 F
            arr[7]++;
            sb.deleteCharAt(sb.toString().indexOf("F"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("V"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
        }

        while (sb.toString().contains("G")) { //8， 独有的 G, 
            arr[0]++;
            sb.deleteCharAt(sb.toString().indexOf("E"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("G"));
            sb.deleteCharAt(sb.toString().indexOf("H"));
            sb.deleteCharAt(sb.toString().indexOf("T"));
        }

        //剩下 1 9  ONE NINE
        while (sb.toString().contains("O")) { //1 
            arr[3]++;
            sb.deleteCharAt(sb.toString().indexOf("O"));
            sb.deleteCharAt(sb.toString().indexOf("N"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
        }
        while (sb.toString().contains("I")) { //9
            arr[1]++;
            sb.deleteCharAt(sb.toString().indexOf("N"));
            sb.deleteCharAt(sb.toString().indexOf("I"));
            sb.deleteCharAt(sb.toString().indexOf("N"));
            sb.deleteCharAt(sb.toString().indexOf("E"));
        }

        // 索引 i 的值  arr[i] 不为0, 输出 i，输出次数为 arr[i]
        for (int i = 0; i < arr.length; i++) {
            // arr[i] >= 1 时，循环输出
            if (arr[i]!=0){
                for (int j = 0; j <arr[i] ; j++) {
                    System.out.print(i);
                }
            }

        }

    }
}


```


# 扩展


## 题目


Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.
**Note**
    1. Input contains only lowercase English letters.
    2. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.
    3. Input length is less than 50,000.



## Example

```
Input: "owoztneoer"

Output: "012"

Input: "fviefuro"

Output: "45"

```


## Coding

此代码适用于任何合法输入的还原

```
    // zero one two three four five six seven eight nine
    //find the unique character of each letter
    // zero -- z , two - w , six -x , eight - g, four - u
    // s -- seven,six     h -- three ,eight    f -- five ,four
    // o -- one zero four two  i-- nine five
    public static String originalDigits(String s) {

        int count[] = new int[10];
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == 'z') count[0]++;  // 0
            if (c == 'w') count[2]++;  // 2
            if (c == 'x') count[6]++;  // 6
            if (c == 's') count[7]++;  // 6 7 => we have got the count of 6
            if (c == 'g') count[8]++;  // 8
            if (c == 'u') count[4]++;  // 4
            if (c == 'f') count[5]++;  // 4 5 => we have got the count of 4
            if (c == 'h') count[3]++;  // 8 3 => we have got the count of 3
            if (c == 'i') count[9]++;  // 5 9 8 6 => we have got the count of  5
            if (c == 'o') count[1]++;  // 0 2 4 1 => we have got the count of  0 2 4

        }

        count[7] = count[7] - count[6];
        count[5] = count[5] - count[4];
        count[3] = count[3] - count[8];
        count[9] = count[9] - count[8] - count[5] - count[6];
        count[1] = count[1] - count[0] - count[2] - count[4];

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i <= 9; i++) {
            for (int k = 0; k < count[i]; k++) {
                sb.append(i);
            }

        }
        return sb.toString();

    }
```


