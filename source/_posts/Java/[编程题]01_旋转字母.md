[编程题]00_密码加密

---
title: '[编程题]01_旋转字母'
category: 编程题
tag: 编程题
date: 2018-03-20 00:01:00
---


# 题目

给定两个整数M，N，生成一个M*N的矩阵，矩阵中元素取值为A至Z的26个字母中的一个，A在左上角，其余各数按顺时针方向旋转前进，依次递增放置，当超过26时又从A开始填充。例如，当M=5，N=8时，矩阵中的内容如下：

```
   A   B   C   D   E   F   G   H

   V   W   X   Y   Z   A   B   I

   U   J   K   L   M   N   C   J

   T   I   H   G   F   E   D   K

   S   R   Q   P   O   N   M   L
```

## 输入例子

```
4 9
```

## 输出例子

```
   A   B   C   D   E   F   G   H   I
   V   W   X   Y   Z   A   B   C   J
   U   J   I   H   G   F   E   D   K
   T   S   R   Q   P   O   N   M   L
```

# 代码实现

用面向对象的思想思考这道题就很费劲了，想是一回事，实现又是另一回事了，逻辑要十分严密，复杂度不可过高，可以使用递归

```
import java.util.*;

public class XuanZhuanZiMu2 {


    /*1. 输入  R * C 的矩阵
      2. A 在 左上角 ，起点， 其他字母按  顺时针 顺序排列
      3. 当字母到达 Z 之后， 从 A 重新开始
      */
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int R = s.nextInt();
        int C = s.nextInt();
        go(R, C);
    }


    //方法重载，简化输入
    public static void go(int R, int C) {
        String[][] ele = new String[R][C];
        ele[0][0] ="A";
        go(0, 1, R, C, 0, ele, 1);
        
        //输出矩阵内的元素
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {

                System.out.print(ele[i][j]);
            }
            System.out.println();
        }
    }

    /**
     * 递归遍历每个元素， 第 n 次 循环结束， 起始点边界 +n ，结束点边界 -n。 当不满足任意方向时，代表下一轮循环开始，round++
     *
     * @param i        当前行 索引
     * @param j        当前列索引
     * @param R        矩阵行数
     * @param C        矩阵列数
     * @param round    第几轮循环
     * @param elements 矩阵
     * @param step     一共走的步数
     */
    public static void go(int i, int j, int R, int C, int round, String[][] elements, int step) {
        //定义数据字典
        String[] sa = {
                "A", "B", "C", "D",
                "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
                "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X",
                "Y", "Z"};
        List<String> l = new ArrayList<>(Arrays.asList(sa));
        //排序
        Collections.sort(l);
        if (i == round && j < C - (round + 1)) {
            //在 i==round 说明在空闲区 起始位置 ，向右移动，可移动到列 C -(round+1) 位置
            //System.out.println("当前位置：" + i + "--" + j + "\t: 向右走");
            elements[i][j] = l.get(step % 26);
            j++;
            step++;
            if (step >= R * C) {
                return;
            }
            elements[i][j] = l.get(step % 26);
            go(i, j, R, C, round, elements, step);
        } else if (i == R - (round + 1) && j > round) {

            //在 i = R-(round+1) 时 ，说明在 空闲区 最后一行 最后一列 ，可 向左  移动 round 列
            elements[i][j] = l.get(step % 26);
            j--;
            step++;
            if (step >= R * C) {
                return;
            }
            elements[i][j] = l.get(step % 26);
            go(i, j, R, C, round, elements, step);
        } else if (i < R - (round + 1) && j == C - (round + 1)) {

            //在  j == C - (round + 1) 时，说明在空闲区 第一行 最后 一列，可  向下   移动至  R - (round + 1) 行
            //System.out.println("当前位置：" + i + "--" + j + "\t: 向下走");
            elements[i][j] = l.get(step % 26);
            i++;
            step++;
            if (step >= R * C) {
                return;
            }
            elements[i][j] = l.get(step % 26);
            go(i, j, R, C, round, elements, step);
        } else if (i > round + 1 && j == round) {

            //当前处于空闲区第一列，最后一行，可以  向上  移动 至 round + 1 行
            //System.out.println("当前位置：" + i + "--" + j + "\t: 向上走");
            elements[i][j] = l.get(step % 26);
            i--;
            step++;
            if (step >= R * C) {
                return;
            }
            elements[i][j] = l.get(step % 26);
            go(i, j, R, C, round, elements, step);
        } else {

            //不满足任何方向移动，说明下一轮循环开始 ， round++, 再递归
            round++;
            if (step >= R * C - 1) {
                return;
            }
            go(i, j, R, C, round, elements, step);
        }

    }

}


```

