(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{299:function(e,v,_){"use strict";_.r(v);var o=_(13),a=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"_1-3-go-命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-go-命令"}},[e._v("#")]),e._v(" 1.3 Go 命令")]),e._v(" "),_("h2",{attrs:{id:"go-命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-命令"}},[e._v("#")]),e._v(" Go 命令")]),e._v(" "),_("p",[e._v("Go语言自带有一套完整的命令操作工具，你可以通过在命令行中执行"),_("code",[e._v("go")]),e._v("来查看它们：")]),e._v(" "),_("p",[_("img",{attrs:{src:"images/1.1.mac.png?raw=true",alt:""}})]),e._v(" "),_("p",[e._v("图1.3 Go命令显示详细的信息")]),e._v(" "),_("p",[e._v("这些命令对于我们平时编写的代码非常有用，接下来就让我们了解一些常用的命令。")]),e._v(" "),_("h2",{attrs:{id:"go-build"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-build"}},[e._v("#")]),e._v(" go build")]),e._v(" "),_("p",[e._v("这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("如果是普通包，就像我们在1.2节中编写的"),_("code",[e._v("mymath")]),e._v("包那样，当你执行"),_("code",[e._v("go build")]),e._v("之后，它不会产生任何文件。如果你需要在"),_("code",[e._v("$GOPATH/pkg")]),e._v("下生成相应的文件，那就得执行"),_("code",[e._v("go install")]),e._v("。")])]),e._v(" "),_("li",[_("p",[e._v("如果是"),_("code",[e._v("main")]),e._v("包，当你执行"),_("code",[e._v("go build")]),e._v("之后，它就会在当前目录下生成一个可执行文件。如果你需要在"),_("code",[e._v("$GOPATH/bin")]),e._v("下生成相应的文件，需要执行"),_("code",[e._v("go install")]),e._v("，或者使用"),_("code",[e._v("go build -o 路径/a.exe")]),e._v("。")])]),e._v(" "),_("li",[_("p",[e._v("如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在"),_("code",[e._v("go build")]),e._v("之后加上文件名，例如"),_("code",[e._v("go build a.go")]),e._v("；"),_("code",[e._v("go build")]),e._v("命令默认会编译当前目录下的所有go文件。")])]),e._v(" "),_("li",[_("p",[e._v("你也可以指定编译输出的文件名。例如1.2节中的"),_("code",[e._v("mathapp")]),e._v("应用，我们可以指定"),_("code",[e._v("go build -o astaxie.exe")]),e._v("，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。")])])]),e._v(" "),_("p",[e._v("（注：实际上，package名在"),_("a",{attrs:{href:"https://golang.org/ref/spec",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go语言规范"),_("OutboundLink")],1),e._v("中指代码中“package”后使用的名称，此名称可以与文件夹名不同。默认生成的可执行文件名是文件夹名。）")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("go build会忽略目录下以“_”或“.”开头的go文件。")])]),e._v(" "),_("li",[_("p",[e._v("如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件：")]),e._v(" "),_("p",[e._v("array_linux.go\narray_darwin.go\narray_windows.go\narray_freebsd.go")])])]),e._v(" "),_("p",[_("code",[e._v("go build")]),e._v("的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系统下面编译只会选择array_linux.go文件，其它系统命名后缀文件全部忽略。")]),e._v(" "),_("p",[e._v("参数的介绍")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-o")]),e._v(" 指定输出的文件名，可以带上路径，例如 "),_("code",[e._v("go build -o a/b/c")])]),e._v(" "),_("li",[_("code",[e._v("-i")]),e._v(" 安装相应的包，编译+"),_("code",[e._v("go install")])]),e._v(" "),_("li",[_("code",[e._v("-a")]),e._v(" 更新全部已经是最新的包的，但是对标准包不适用")]),e._v(" "),_("li",[_("code",[e._v("-n")]),e._v(" 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的")]),e._v(" "),_("li",[_("code",[e._v("-p n")]),e._v(" 指定可以并行可运行的编译数目，默认是CPU数目")]),e._v(" "),_("li",[_("code",[e._v("-race")]),e._v(" 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器")]),e._v(" "),_("li",[_("code",[e._v("-v")]),e._v(" 打印出来我们正在编译的包名")]),e._v(" "),_("li",[_("code",[e._v("-work")]),e._v(" 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除")]),e._v(" "),_("li",[_("code",[e._v("-x")]),e._v(" 打印出来执行的命令，其实就是和"),_("code",[e._v("-n")]),e._v("的结果类似，只是这个会执行")]),e._v(" "),_("li",[_("code",[e._v("-ccflags 'arg list'")]),e._v(" 传递参数给5c, 6c, 8c 调用")]),e._v(" "),_("li",[_("code",[e._v("-compiler name")]),e._v(" 指定相应的编译器，gccgo还是gc")]),e._v(" "),_("li",[_("code",[e._v("-gccgoflags 'arg list'")]),e._v(" 传递参数给gccgo编译连接调用")]),e._v(" "),_("li",[_("code",[e._v("-gcflags 'arg list'")]),e._v(" 传递参数给5g, 6g, 8g 调用")]),e._v(" "),_("li",[_("code",[e._v("-installsuffix suffix")]),e._v(" 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，"),_("code",[e._v("-race")]),e._v("的时候默认已经是"),_("code",[e._v("-installsuffix race")]),e._v(",大家可以通过"),_("code",[e._v("-n")]),e._v("命令来验证")]),e._v(" "),_("li",[_("code",[e._v("-ldflags 'flag list'")]),e._v(" 传递参数给5l, 6l, 8l 调用")]),e._v(" "),_("li",[_("code",[e._v("-tags 'tag list'")]),e._v(" 设置在编译的时候可以适配的那些tag，详细的tag限制参考里面的 "),_("a",{attrs:{href:"http://golang.org/pkg/go/build/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Build Constraints"),_("OutboundLink")],1)])]),e._v(" "),_("h3",{attrs:{id:"linux下跨平台编译"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#linux下跨平台编译"}},[e._v("#")]),e._v(" Linux下跨平台编译")]),e._v(" "),_("p",[e._v("以下命令适用与其他操作系统")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("MacOS可执行文件")]),e._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("CGO_ENABLED")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("GOOS")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("darwin "),_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("GOARCH")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("amd64 go build test.go\n")])])])]),e._v(" "),_("li",[_("p",[e._v("Windows可执行文件")]),e._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("CGO_ENABLED")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v(" "),_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("GOOS")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("windows "),_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("GOARCH")]),_("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("amd64 go build test.go\n")])])])])]),e._v(" "),_("h2",{attrs:{id:"go-clean"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-clean"}},[e._v("#")]),e._v(" go clean")]),e._v(" "),_("p",[e._v("这个命令是用来移除当前源码包和关联源码包里面编译生成的文件。这些文件包括")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("_obj/            旧的object目录，由Makefiles遗留\n_test/           旧的test目录，由Makefiles遗留\n_testmain.go     旧的gotest文件，由Makefiles遗留\ntest.out         旧的test记录，由Makefiles遗留\nbuild.out        旧的test记录，由Makefiles遗留\n*.[568ao]        object文件，由Makefiles遗留\n\nDIR(.exe)        由go build产生\nDIR.test(.exe)   由go test -c产生\nMAINFILE(.exe)   由go build MAINFILE.go产生\n*.so             由 SWIG 产生\n")])])]),_("p",[e._v("我一般都是利用这个命令清除编译文件，然后GitHub递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("$ go clean -i -n\ncd /Users/astaxie/develop/gopath/src/mathapp\nrm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe\nrm -f /Users/astaxie/develop/gopath/bin/mathapp\n")])])]),_("p",[e._v("参数介绍")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-i")]),e._v(" 清除关联的安装的包和可运行文件，也就是通过go install安装的文件")]),e._v(" "),_("li",[_("code",[e._v("-n")]),e._v(" 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的")]),e._v(" "),_("li",[_("code",[e._v("-r")]),e._v(" 循环的清除在import中引入的包")]),e._v(" "),_("li",[_("code",[e._v("-x")]),e._v(" 打印出来执行的详细命令，其实就是"),_("code",[e._v("-n")]),e._v("打印的执行版本")])]),e._v(" "),_("h2",{attrs:{id:"go-fmt"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-fmt"}},[e._v("#")]),e._v(" go fmt")]),e._v(" "),_("p",[e._v("有过C/C++经验的读者会知道,一些人经常为代码采取K&R风格还是ANSI风格而争论不休。在go中，代码则有标准的风格。由于之前已经有的一些习惯或其它的原因我们常将代码写成ANSI风格或者其它更合适自己的格式，这将为人们在阅读别人的代码时添加不必要的负担，所以go强制了代码格式（比如左大括号必须放在行尾），不按照此格式的代码将不能编译通过，为了减少浪费在排版上的时间，go工具集中提供了一个"),_("code",[e._v("go fmt")]),e._v("命令 它可以帮你格式化你写好的代码文件，使你写代码的时候不需要关心格式，你只需要在写完之后执行"),_("code",[e._v("go fmt <文件名>.go")]),e._v("，你的代码就被修改成了标准格式，但是我平常很少用到这个命令，因为开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了"),_("code",[e._v("go fmt")]),e._v("。接下来的一节我将讲述两个工具，这两个工具都自带了保存文件时自动化"),_("code",[e._v("go fmt")]),e._v("功能。")]),e._v(" "),_("p",[e._v("使用go fmt命令，其实是调用了gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w -l src，可以格式化整个项目。")]),e._v(" "),_("p",[e._v("所以go fmt是gofmt的上层一个包装的命令，我们想要更多的个性化的格式化可以参考 "),_("a",{attrs:{href:"http://golang.org/cmd/gofmt/",target:"_blank",rel:"noopener noreferrer"}},[e._v("gofmt"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("gofmt的参数介绍")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-l")]),e._v(" 显示那些需要格式化的文件")]),e._v(" "),_("li",[_("code",[e._v("-w")]),e._v(" 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。")]),e._v(" "),_("li",[_("code",[e._v("-r")]),e._v(" 添加形如“a[b:len(a)] -> a[b:]”的重写规则，方便我们做批量替换")]),e._v(" "),_("li",[_("code",[e._v("-s")]),e._v(" 简化文件中的代码")]),e._v(" "),_("li",[_("code",[e._v("-d")]),e._v(" 显示格式化前后的diff而不是写入文件，默认是false")]),e._v(" "),_("li",[_("code",[e._v("-e")]),e._v(" 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误。")]),e._v(" "),_("li",[_("code",[e._v("-cpuprofile")]),e._v(" 支持调试模式，写入相应的cpufile到指定的文件")])]),e._v(" "),_("h2",{attrs:{id:"go-get"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-get"}},[e._v("#")]),e._v(" go get")]),e._v(" "),_("p",[e._v("这个命令是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行"),_("code",[e._v("go install")]),e._v("。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("BitBucket (Mercurial Git)\nGitHub (Git)\nGoogle Code Project Hosting (Git, Mercurial, Subversion)\nLaunchpad (Bazaar)\n")])])]),_("p",[e._v("所以为了"),_("code",[e._v("go get")]),e._v(" 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实"),_("code",[e._v("go get")]),e._v("支持自定义域名的功能，具体参见"),_("code",[e._v("go help remote")]),e._v("。")]),e._v(" "),_("p",[e._v("参数介绍：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-d")]),e._v(" 只下载不安装")]),e._v(" "),_("li",[_("code",[e._v("-f")]),e._v(" 只有在你包含了"),_("code",[e._v("-u")]),e._v("参数的时候才有效，不让"),_("code",[e._v("-u")]),e._v("去验证import中的每一个都已经获取了，这对于本地fork的包特别有用")]),e._v(" "),_("li",[_("code",[e._v("-fix")]),e._v(" 在获取源码之后先运行fix，然后再去做其他的事情")]),e._v(" "),_("li",[_("code",[e._v("-t")]),e._v(" 同时也下载需要为运行测试所需要的包")]),e._v(" "),_("li",[_("code",[e._v("-u")]),e._v(" 强制使用网络去更新包和它的依赖包")]),e._v(" "),_("li",[_("code",[e._v("-v")]),e._v(" 显示执行的命令")])]),e._v(" "),_("h2",{attrs:{id:"go-install"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-install"}},[e._v("#")]),e._v(" go install")]),e._v(" "),_("p",[e._v("这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到"),_("code",[e._v("$GOPATH/pkg")]),e._v("或者"),_("code",[e._v("$GOPATH/bin")]),e._v("。")]),e._v(" "),_("p",[e._v("参数支持"),_("code",[e._v("go build")]),e._v("的编译参数。大家只要记住一个参数"),_("code",[e._v("-v")]),e._v("就好了，这个随时随地的可以查看底层的执行信息。")]),e._v(" "),_("h2",{attrs:{id:"go-test"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-test"}},[e._v("#")]),e._v(" go test")]),e._v(" "),_("p",[e._v("执行这个命令，会自动读取源码目录下面名为"),_("code",[e._v("*_test.go")]),e._v("的文件，生成并运行测试用的可执行文件。输出的信息类似")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("ok   archive/tar   0.011s\nFAIL archive/zip   0.022s\nok   compress/gzip 0.033s\n...\n")])])]),_("p",[e._v("默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考"),_("code",[e._v("go help testflag")])]),e._v(" "),_("p",[e._v("这里我介绍几个我们常用的参数：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-bench regexp")]),e._v(" 执行相应的benchmarks，例如 "),_("code",[e._v("-bench=.")])]),e._v(" "),_("li",[_("code",[e._v("-cover")]),e._v(" 开启测试覆盖率")]),e._v(" "),_("li",[_("code",[e._v("-run regexp")]),e._v(" 只运行regexp匹配的函数，例如 "),_("code",[e._v("-run=Array")]),e._v(" 那么就执行包含有Array开头的函数")]),e._v(" "),_("li",[_("code",[e._v("-v")]),e._v(" 显示测试的详细命令")])]),e._v(" "),_("h2",{attrs:{id:"go-tool"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-tool"}},[e._v("#")]),e._v(" go tool")]),e._v(" "),_("p",[_("code",[e._v("go tool")]),e._v("下面下载聚集了很多命令，这里我们只介绍两个，fix和vet")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("go tool fix .")]),e._v(" 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1,例如API的变化")]),e._v(" "),_("li",[_("code",[e._v("go tool vet directory|files")]),e._v(" 用来分析当前目录的代码是否都是正确的代码,例如是不是调用fmt.Printf里面的参数不正确，例如函数里面提前return了然后出现了无用代码之类的。")])]),e._v(" "),_("h2",{attrs:{id:"go-generate"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go-generate"}},[e._v("#")]),e._v(" go generate")]),e._v(" "),_("p",[e._v("这个命令是从Go1.4开始才设计的，用于在编译前自动化生成某类代码。"),_("code",[e._v("go generate")]),e._v("和"),_("code",[e._v("go build")]),e._v("是完全不一样的命令，通过分析源码中特殊的注释，然后执行相应的命令。这些命令都是很明确的，没有任何的依赖在里面。而且大家在用这个之前心里面一定要有一个理念，这个"),_("code",[e._v("go generate")]),e._v("是给你用的，不是给使用你这个包的人用的，是方便你来生成一些代码的。")]),e._v(" "),_("p",[e._v("这里我们来举一个简单的例子，例如我们经常会使用"),_("code",[e._v("yacc")]),e._v("来生成代码，那么我们常用这样的命令：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("go tool yacc -o gopher.go -p parser gopher.y\n")])])]),_("p",[e._v("-o 指定了输出的文件名， -p指定了package的名称，这是一个单独的命令，如果我们想让"),_("code",[e._v("go generate")]),e._v("来触发这个命令，那么就可以在当前目录的任意一个"),_("code",[e._v("xxx.go")]),e._v("文件里面的任意位置增加一行如下的注释：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("//go:generate go tool yacc -o gopher.go -p parser gopher.y\n")])])]),_("p",[e._v("这里我们注意了，"),_("code",[e._v("//go:generate")]),e._v("是没有任何空格的，这其实就是一个固定的格式，在扫描源码文件的时候就是根据这个来判断的。")]),e._v(" "),_("p",[e._v("所以我们可以通过如下的命令来生成，编译，测试。如果"),_("code",[e._v("gopher.y")]),e._v("文件有修改，那么就重新执行"),_("code",[e._v("go generate")]),e._v("重新生成文件就好。")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("$ go generate\n$ go build\n$ go test\n")])])]),_("h2",{attrs:{id:"godoc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#godoc"}},[e._v("#")]),e._v(" godoc")]),e._v(" "),_("p",[e._v("在Go1.2版本之前还支持"),_("code",[e._v("go doc")]),e._v("命令，但是之后全部移到了godoc这个命令下，需要这样安装"),_("code",[e._v("go get golang.org/x/tools/cmd/godoc")])]),e._v(" "),_("p",[e._v("很多人说go不需要任何的第三方文档，例如chm手册之类的（其实我已经做了一个了，"),_("a",{attrs:{href:"https://github.com/astaxie/godoc",target:"_blank",rel:"noopener noreferrer"}},[e._v("chm手册"),_("OutboundLink")],1),e._v("），因为它内部就有一个很强大的文档工具。")]),e._v(" "),_("p",[e._v("如何查看相应package的文档呢？\n例如builtin包，那么执行"),_("code",[e._v("godoc builtin")]),e._v("\n如果是http包，那么执行"),_("code",[e._v("godoc net/http")]),e._v("\n查看某一个包里面的函数，那么执行"),_("code",[e._v("godoc fmt Printf")]),e._v("\n也可以查看相应的代码，执行"),_("code",[e._v("godoc -src fmt Printf")])]),e._v(" "),_("p",[e._v("通过命令在命令行执行 godoc -http=:端口号 比如"),_("code",[e._v("godoc -http=:8080")]),e._v("。然后在浏览器中打开"),_("code",[e._v("127.0.0.1:8080")]),e._v("，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地"),_("code",[e._v("GOPATH")]),e._v("中所有项目的相关文档，这对于经常被墙的用户来说是一个不错的选择。")]),e._v(" "),_("h2",{attrs:{id:"其它命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其它命令"}},[e._v("#")]),e._v(" 其它命令")]),e._v(" "),_("p",[e._v("go还提供了其它很多的工具，例如下面的这些工具")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("go version 查看go当前的版本\ngo env 查看当前go的环境变量\ngo list 列出当前全部安装的package\ngo run 编译并运行Go程序\n")])])]),_("p",[e._v("以上这些工具还有很多参数没有一一介绍，用户可以使用"),_("code",[e._v("go help 命令")]),e._v("获取更详细的帮助信息。")]),e._v(" "),_("h2",{attrs:{id:"links"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" links")]),e._v(" "),_("ul",[_("li",[_("RouterLink",{attrs:{to:"/编程语言/Go/preface.html"}},[e._v("目录")])],1),e._v(" "),_("li",[e._v("上一节: "),_("RouterLink",{attrs:{to:"/编程语言/Go/01.2.html"}},[e._v("GOPATH与工作空间")])],1),e._v(" "),_("li",[e._v("下一节: "),_("RouterLink",{attrs:{to:"/编程语言/Go/01.4.html"}},[e._v("Go开发工具")])],1)])])}),[],!1,null,null,null);v.default=a.exports}}]);