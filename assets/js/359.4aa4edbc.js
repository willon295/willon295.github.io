(window.webpackJsonp=window.webpackJsonp||[]).push([[359],{344:function(n,t,e){"use strict";e.r(t);var a=e(13),r=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"object"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object"}},[n._v("#")]),n._v(" object")]),n._v(" "),e("ol",[e("li",[n._v("静态对象")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('object Student(){\n\t//对象里面的 变量为静态变量，可以通过对象直接调用\n\tval CONSTANT="demo"\n\t\n\t//private修饰的变量 在其他对象中不可访问\n\tprivate val PASSWORD = "333444"\n\t\n\t//对象里面的方法为静态方法，可以通过对象直接调用\n\tdef sayHi(){\n\t\tprintln("Hi~")\n\t}\n}\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[n._v("伴生对象\n=> 和类名相同，且在同一个文件中")]),n._v(" "),e("li",[n._v("单例对象，scala的对象就是单例对象")]),n._v(" "),e("li",[n._v("当对象继承 "),e("code",[n._v("App")]),n._v(" 对象时，不需要 "),e("code",[n._v("main")]),n._v(" 方法即可执行")])]),n._v(" "),e("h2",{attrs:{id:"静态对象的-apply-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态对象的-apply-方法"}},[n._v("#")]),n._v(" 静态对象的 apply 方法")]),n._v(" "),e("ol",[e("li",[n._v("相当于类的构造方法，有返回值")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('//定义apply方法\nobject Demo {\n\n  def apply(): Unit = {\n    println("run apply")\n  }\n  def apply(i:String  ): String  = {\n    "run apply"+i\n  }\n  def apply(i: Int, j: Int): Int  = {\n    i + j\n  }\n}\n\n//测试\nobject HelloWorld {\n  def main(args: Array[String]): Unit = {\n\n    val a = Demo\n    val a1 =Demo("sss")\n    val a2 = Demo(1,5)\n\n    println(a)\n    println(a1)\n    println(a2)\n  }\n\n\n}\n\n')])])]),e("h1",{attrs:{id:"特质-trait"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特质-trait"}},[n._v("#")]),n._v(" 特质 trait")]),n._v(" "),e("p",[n._v("特质相当于java中的接口")]),n._v(" "),e("ol",[e("li",[n._v("特质的所有方法和成员可以都是抽象的，不需要abstract")]),n._v(" "),e("li",[n._v("特质可以混入 类、对象、特质、实例中")]),n._v(" "),e("li",[n._v("实例混入特质的构造顺序\n"),e("ul",[e("li",[n._v("超特质 -> 父特质 -> 类 -> 从左往右特质")])])]),n._v(" "),e("li",[n._v("如果 "),e("code",[n._v("多个特质")]),n._v(" 重写 "),e("code",[n._v("同一个特质")]),n._v(" 的 "),e("code",[n._v("同一个方法")]),n._v("，方法前必须要 "),e("code",[n._v("override")])])]),n._v(" "),e("h2",{attrs:{id:"贴代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#贴代码"}},[n._v("#")]),n._v(" 贴代码")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('trait Log {\n  println("LOG")\n  def log()\n}\n\ntrait FileLog extends Log {\n  println("FILE_LOG")\n  override def log(): Unit = {\n    println("File log ...")\n  }\n}\n\ntrait ConsleLog extends Log {\n  println("CONSLE_LOG")\n  override def log(): Unit = {\n    println("Consle log ...")\n  }\n}\n\ntrait IOlog extends Log {\n  println("IO_LOG")\n  override def log(): Unit = {\n    println("IO log...")\n  }\n}\n\n\n\n\nclass TestLog extends Log {\n  println("INSTANCE ---  INIT")\n  override def log(): Unit = {\n    println("IO  log")\n  }\n}\n\nobject TestLog {\n  def main(args: Array[String]): Unit = {\n    val log = new TestLog with ConsleLog with FileLog\n    log.log()\n  }\n}\n\n\n\n')])])]),e("ol",[e("li",[n._v("当创建实例时，混入多个特质，那么那些特质中的相同方法名之前 override 关键字不能省略，省略会产生二异性")])]),n._v(" "),e("h2",{attrs:{id:"如果特质需要传递参数怎么办"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果特质需要传递参数怎么办"}},[n._v("#")]),n._v(" 如果特质需要传递参数怎么办？")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('\nimport java.io.{InputStream, PrintStream}\n\n//父类特质\ntrait Logger {\n  def log()\n}\n\n//特质，需要传入两个参数 ， 一个文件名 ，一个文件内容\ntrait FileLogger extends Logger {\n  val fielname: String\n  val content:String\n  lazy val os = new PrintStream(fielname)\n  override def log(): Unit = {\n    os.write(content.getBytes())\n  }\n}\n\n\n//没有任何东西的 类\nclass DynamicClassExtention {\n  \n  \n}\n\n\n\n\nobject DynamicClassExtention {\n  def main(args: Array[String]): Unit = {\n    //对 类进行功能扩展 ，传入参数\n    val d = new DynamicClassExtention with FileLogger {\n      override val fielname: String = "a.txt"\n      override val content: String = "file error"\n    }\n    d.log()\n\n  }\n}\n\n')])])]),e("ol",[e("li",[n._v("为了避免特质构造时发生空指针异常，将其被调用处资源 申明为 "),e("code",[n._v("lazy")])]),n._v(" "),e("li",[n._v("在混入特质时，需要重写其属性，并且赋值")])]),n._v(" "),e("h2",{attrs:{id:"super调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super调用"}},[n._v("#")]),n._v(" super调用")]),n._v(" "),e("p",[n._v("如果 "),e("code",[n._v("多个特质")]),n._v(" 重写了 "),e("code",[n._v("同一个方法")]),n._v(" ，且该方法中都调用了父类的方法， 那么具体的调用是 从右往左 开始")]),n._v(" "),e("p",[n._v("举个例子")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//定义一个抽象类和子类\nabstract class CharBuffer {\n  def get: Char\n  def put(c: Char)\n}\n\nclass Overlay extends CharBuffer{\n  val buf = new ArrayBuffer[Char]\n  override def get: Char = {\n    if (buf.length != 0) buf(0) else '@'\n  }\n  override def put(c: Char): Unit = {\n    buf.append(c)\n  }\n}\n\n\n//定义两种对输入字符进行操作的特质:\n//此处继承了 CharBuffer ，只有CharBuffer子类菜可以使用 该特质\ntrait ToUpper extends CharBuffer {\n    // 特质中重写抽象方法  abstract override\n    abstract override def put(c: Char) = super.put(c.toUpper)\n}\ntrait ToLower extends CharBuffer {\n    abstract override def put(c: Char) = super.put(c.toLower)\n}\n\n\n//测试\nobject TestOverlay extends App {\n  val cb1 = new Overlay with ToLower with ToUpper\n  val cb2 = new Overlay with ToUpper with ToLower\n\n  cb1.put('A')\n  println(cb1.get)\n\n  cb2.put('a')\n  println(cb2.get)\n\n}\n\n\n\n\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);