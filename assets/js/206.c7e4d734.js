(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{591:function(e,a,t){"use strict";t.r(a);var r=t(13),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"自定义类的序列化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义类的序列化"}},[e._v("#")]),e._v(" 自定义类的序列化")]),e._v(" "),t("ol",[t("li",[e._v("JAVA原生的序列化并不是非常理想，可以说是臃肿，Hadoop 对序列化进行优化")]),e._v(" "),t("li",[e._v("在 Hadoop 的序列化中，所有的数据应该可以比较大小所以自定义的类 需要实现 "),t("code",[e._v("Comparable")])])]),e._v(" "),t("h2",{attrs:{id:"接口介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口介绍"}},[e._v("#")]),e._v(" 接口介绍")]),e._v(" "),t("p",[e._v("Hadoop 有以下接口")]),e._v(" "),t("h3",{attrs:{id:"writable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#writable"}},[e._v("#")]),e._v(" Writable")]),e._v(" "),t("p",[e._v("该接口有两个方法需要重载， "),t("code",[e._v("readFileds()")]),e._v(" , "),t("code",[e._v("write()")])]),e._v(" "),t("h3",{attrs:{id:"comparable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#comparable"}},[e._v("#")]),e._v(" Comparable")]),e._v(" "),t("p",[e._v("方法 "),t("code",[e._v("compareTo()")]),e._v(",而为了避免歧义，通常也会重写 "),t("code",[e._v("equals()")]),e._v(" 和 "),t("code",[e._v("hashCode()")])]),e._v(" "),t("h1",{attrs:{id:"sequencefile文件序列化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sequencefile文件序列化"}},[e._v("#")]),e._v(" SequenceFile文件序列化")]),e._v(" "),t("p",[e._v("Hadoop序列化文件SequenceFile可以用于解决大量小文件（所谓小文件：泛指小于block大小的文件）问题，SequenceFile是Hadoop API提供的一种二进制文件支持。这种二进制文件直接将<key,value>对序列化到文件中，一般对小文件可以使用这种文件合并，即将文件名作为key，文件内容作为value序列化到大文件中。")]),e._v(" "),t("h2",{attrs:{id:"序列化写入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#序列化写入"}},[e._v("#")]),e._v(" 序列化写入")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('String [] DATA = {"aa","bb","cc "}\nConfiguration conf = new Configuration();\nPath path  =  new Path("/a.seq");\nIntWritable key = new IntWritable();  \nText value = new Text();  \nWriter writer = SequenceFile.createWriter(conf, Writer.file(path), Writer.keyClass(key.getClass()),  \n                    Writer.valueClass(value.getClass()), Writer.compression(CompressionType.BLOCK));  \nfor (int i = 0; i < 4; i++) {  \n\tvalue.set(DATA[i]);  \n\tkey.set(i);  \n\tSystem.out.printf("[%s]\\t%s\\t%s\\n", writer.getLength(), key, value);  \n\twriter.append(key, value);  \n}  \n\n')])])]),t("h2",{attrs:{id:"序列化读取-待完善"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#序列化读取-待完善"}},[e._v("#")]),e._v(" 序列化读取(待完善)")])])}),[],!1,null,null,null);a.default=s.exports}}]);