(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{397:function(a,t,n){"use strict";n.r(t);var s=n(13),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"题目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[a._v("#")]),a._v(" 题目")]),a._v(" "),n("p",[a._v("括号匹配，() , {} ,[] 为匹配")]),a._v(" "),n("h2",{attrs:{id:"input"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#input"}},[a._v("#")]),a._v(" Input")]),a._v(" "),n("p",[a._v("第一个参数 M 是测试用例的个数， 之后输入 M  行测试用例，输入只包含 "),n("code",[a._v("(){}[]")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("3\n{[](()}\n[][]()\n()(([]))\n")])])]),n("h2",{attrs:{id:"output"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#output"}},[a._v("#")]),a._v(" Output")]),a._v(" "),n("p",[a._v("输出每行的匹配结果")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("false\ntrue\ntrue\n")])])]),n("h1",{attrs:{id:"coding"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#coding"}},[a._v("#")]),a._v(" Coding")]),a._v(" "),n("p",[a._v("栈的使用")]),a._v(" "),n("h2",{attrs:{id:"_2018-04-04更新"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2018-04-04更新"}},[a._v("#")]),a._v(" 2018-04-04更新")]),a._v(" "),n("p",[a._v("今天脑子比较清醒，看了下以前的代码，简直不认直视。复杂度太高，占用内存太多。主要原因是 new 的实例太多，判断太多，于是重新考虑换个算法。\n观察括号的 asc码之后发现了新大陆。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("  ( = 40 ，  )=41\n  [ = 91 ，  ]=93\n  { = 123，  }=125\n\n")])])]),n("ol",[n("li",[n("code",[a._v("匹配")]),a._v(" 的括号之间的差满足：  "),n("code",[a._v("0 < 差 < 3")]),a._v(" => "),n("code",[a._v("41-40=1 93-91=2 125-123=2")])])]),a._v(" "),n("p",[a._v("那么再用栈不就是几行代码的事么")]),a._v(" "),n("h3",{attrs:{id:"java代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java代码"}},[a._v("#")]),a._v(" Java代码")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("    public  boolean isValid(String s) {\n        //奇数个字符，不匹配\n        if (s.length() % 2 != 0) {\n            return false;\n        }\n        \n        // 栈不为空 && c 和 栈顶 匹配 ？弹栈  ： c 进栈\n        Stack<Character> st = new Stack<>();\n        for (char c : s.toCharArray()) {\n            Character n = !st.isEmpty() && ((c - st.lastElement()) < 3) && ((c - st.lastElement()) > 0) ? st.pop() : st.push(c);\n        }\n        return st.isEmpty();\n    }\n\n")])])]),n("h2",{attrs:{id:"_2018-0302-更新"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2018-0302-更新"}},[a._v("#")]),a._v(" 2018-0302 更新")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class KuoHaoPipei {\n\n    public static void main(String[] args) throws IOException {\n        Scanner s = new Scanner(System.in);\n\n        //测试用例的个数\n        int n = s.nextInt();\n\n        //按行 读取测试用例\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        for (int i = 0; i < n; i++) {\n\n            String s1 = bf.readLine();\n            //将 字符串拆成 char数组\n            char[] chars = s1.toCharArray();\n            //将 char 数组元素进行匹配， 输出匹配的结果\n            boolean re = pipei(chars);\n            System.out.println(re);\n        }\n\n\n    }\n\n\n    public static boolean pipei(char[] chars) {\n\n        Stack<Character> stack = new Stack<>();\n\n        //如果长度是 奇数， 不匹配\n        if (chars.length % 2 != 0) {\n            return false;\n        }\n        //放入元素 ， 与栈顶元素比较\n        for (char aChar : chars) {\n            //如果栈为空，添加一个元素，不做其他处理\n            if (stack.empty()) {\n                stack.push(aChar);\n            } else {\n                //栈不为空， 栈顶元素 与 栈顶第二个元素比较 ，（） [] 为匹配\n                stack.push(aChar);\n                if ((stack.get(stack.size() - 2).toString().equals("(")) && stack.get(stack.size() - 1).toString().equals(")")\n                        || (stack.get(stack.size() - 2).toString().equals("[") && stack.get(stack.size() - 1).toString().equals("]"))\n                        || (stack.get(stack.size() - 2).toString().equals("{") && stack.get(stack.size() - 1).toString().equals("}"))) {\n                    //匹配，栈顶 两个元素 弹栈 ，栈空\n                    stack.pop();\n                    stack.pop();\n                }\n            }\n        }\n\n        return stack.empty();\n    }\n}\n\n')])])])])}),[],!1,null,null,null);t.default=e.exports}}]);