(window.webpackJsonp=window.webpackJsonp||[]).push([[358],{347:function(n,a,t){"use strict";t.r(a);var e=t(13),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"类的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的定义"}},[n._v("#")]),n._v(" 类的定义")]),n._v(" "),t("ol",[t("li",[n._v("类名可以和文件名不同")]),n._v(" "),t("li",[n._v("类可以有一个伴生对象")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package day02\n\nclass Student {\n\n  // val 修饰的属性  不可改变，相当于 用 final 修饰\n  val name = "tom"\n  var age = 10\n\n  //  var 修饰的实行 可以改变 相当于有 set get 方法的属性\n  val id: Int = 100\n\n  //private 修饰的属性 只能在 本类、伴生对象 进行访问和操作，在类之外不可以\n  private var sex = "man"\n  \n  \n  //private[this] 修饰的变量只能在 类的内部 使用\n  private[this] var password = "333444"\n  \n  \n  def  printName(): Unit ={\n    println(age)\n  }\n}\n\n//伴生对象 ， 根类名相同 且在同一个文件中\nobject Student{\n\n\n  //定义在 object 里面的方法相当于 java里面的 static 方法\n  def main(args: Array[String]): Unit = {\n\n    val s = new Student\n    s.printName()\n\n  }\n}\n')])])]),t("h1",{attrs:{id:"构造器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造器"}},[n._v("#")]),n._v(" 构造器")]),n._v(" "),t("ol",[t("li",[n._v("在类名定义的构造器叫主构造器，一般主构造器为无参构造器")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//主构造器的  变量 会变成成员变量\n//如果构造器定义一个没有 val ,var修饰的变量，相当于用 private[this] 修饰\nclass Teacher(val id: Int, var name: String, var age: Int, var position: String) {\n  \n  //主构造器之外的成员  初始值 设置为 null 或者 _\n  var gender: String = _\n  \n  //辅助构造器 名称都为 this(...)\n  def this(id: Int, name: String, age: Int, position: String, gender: String) {\n    \n    //必须先调用主构造器\n    this(id, name, age, position)\n    //给其他成员赋值\n    this.gender = gender\n  }\n}\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("在类内部定义的构造器叫辅助构造器")]),n._v(" "),t("li",[n._v("主构造器用 "),t("code",[n._v("private")]),n._v(" 修饰时（class Teacher private(....) ），只能在伴生对象中使用")]),n._v(" "),t("li",[t("code",[n._v("class")]),n._v(" 之前用 "),t("code",[n._v("private[day02]")]),n._v("=> 只能在 day02 包内访问")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("private[day02] class Teacher(){}\n")])])]),t("h1",{attrs:{id:"case-class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#case-class"}},[n._v("#")]),n._v(" case class")]),n._v(" "),t("p",[n._v("基本的语法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("case class Demo(v:A,v2:B....){...}\n")])])]),t("p",[n._v("举个例子")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//属性默认使用 val 修饰\ncase class Student(id:Int,name:String)\n\n//可以new实例，也可以不用 new \nval s1 = Student(1,"Lilei")\nval s2 = new Student(2,"Jili")\n\n\n//可以获取属性的值,但是不可赋值改变\ns1.id\n\n//可以通过cpoy方法改变某个属性的值，返回一个新的对象\n\nval s3 = s2.copy(name="ZhangSan")\n\n//s3 = Student(2,"ZhangSan")\n\n\n')])])]),t("h1",{attrs:{id:"抽象类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[n._v("#")]),n._v(" 抽象类")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('package ooad\n\nabstract class Father {\n  def run():String\n  var name:String\n  val age:Int\n  var birthDay:Int = 1992\n}\n\nclass Son extends Father {\n   def run(): String = {\n    println("son run ")\n    "yes"\n  }\n\n  var name = "sdf"\n  val age: Int = 23\n  birthDay = 2019\n}\n\n\nobject Son {\n\n  def main(args: Array[String]): Unit = {\n    val son: Son = new Son\n    println(son.age, son.name, son.run(), son.birthDay)\n  }\n}\n')])])]),t("ol",[t("li",[n._v("抽象类默认所有 属性和 方法都是抽象的")]),n._v(" "),t("li",[n._v("子类重写父类的属性时\n"),t("ul",[t("li",[n._v("var , val 要相同")]),n._v(" "),t("li",[n._v("可以不使用关键字 override")]),n._v(" "),t("li",[n._v("父类中有具体值的属性，不能使用override重写，直接重写,不需要 val和var修饰")])])]),n._v(" "),t("li",[n._v("子类重写父类方法时\n"),t("ul",[t("li",[n._v("可以不使用override关键字")]),n._v(" "),t("li",[n._v("返回值和函数名称参数列表都要相同")])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);